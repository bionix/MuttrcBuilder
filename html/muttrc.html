<%once>
use Mutt::Config;
</%once>
<%args>
$version # Version of mutt we're configuring
$format  # What sort of output the user requested
</%args>
<%init>
die("Invalid version") if ($version =~ m/[^0-9A-Za-z_.-]/);
my $mutt = Mutt::Config->new($version);

# Sigh. Apache2 has a different call for setting content type it seems.
if ($r->can("content_type")) {
  $r->content_type("text/plain");
} else {
  $r->header_out("Content-Type" => "text/plain");
}
</%init>
# Generated by the muttrc builder (http://muttrcbuilder.org/)
# for mutt-<% $version %>
% if ($format eq "full") {

%   my %seen;            # Keep track of variables missed for some reason
%   my $current_command; # Which command are we in now?
%   foreach(split /\n/, $mutt->manual()) { # Foreach line
%     if (m/^#  ([A-Za-z].*)/) { # Is it a command (2-space indent?
%       my $new_command = $1;
%       if (my $c = $current_command) { # Before we start the new
%                                       # command, do we need to finish
%                                       # the old one?
%         $seen{$current_command}++; # We saw this command
%         my $obj = $mutt->variable($c);
%         $m->comp("SELF:print_variable", option => $obj,
%           args => \%ARGS, always => 1);
%         # Separator to start new command
#
##########
%       }
%       $current_command = $new_command;
%     } # if is-command
%     # And print the manual line we just read
%     if ($_ ne "#  END") {
<% $_ %>
%     }
%   } # foreach

# Other variables

%   foreach my $c (sort grep { not $seen{$_} } # Ones we didn't print above
%     keys %{ $mutt->variables() }) {
%     my $obj = $mutt->variable($c);
%     $m->comp("SELF:print_variable", option => $obj,
%       args => \%ARGS, always => 1);
%   }
%
% } elsif($format eq "categories") {
%   foreach my $cat (sort $mutt->categories()) {

##########
# Category <% $cat %>
##########

%     foreach my $c (sort keys %{ $mutt->variables($cat) }) {
%       my $obj = $mutt->variable($c);
%       $m->comp("SELF:print_variable", option => $obj,
%         args => \%ARGS, always => 1);
%     }
%   }
%
%  } else {

%    foreach my $c (sort keys %{ $mutt->variables() }) {
%       my $obj = $mutt->variable($c);
%       $m->comp("SELF:print_variable", option => $obj,
%         args => \%ARGS, always => ($format eq "all"));
%     }
% }

# Colors

% foreach my $k (sort keys %ARGS) {
%   next unless $k =~ m/^col_fg_([a-z0-9_-]+)/;
color <% sprintf("%-10s %-12s %s", $1, $ARGS{"col_fg_$1"}, $ARGS{"col_bg_$1"}) %>
% }
<%method print_variable><%args>
$args   # HTTP args
$always # Print commented out if not set
$option # Mutt::Config::Option to be printed
</%args>
%       my $default_value = $option->default();
%       $default_value =~ s/&quot;/"/g;    # Sort out quote marks
%       $default_value =~ s/^"(.*)"$/$1/g; # Remove wrapping quotes
%       my $current_value = $args->{"opt_" .
%         $option->name()};                # User-assigned value
%
%       my $quote = "'"; # The quote marks we plan to output
%       if ($option->type() eq "boolean" or
%           $option->type() eq "quadoption") {
%           $quote = ""; # These types need no quotes
%       }
%
%       if (not defined($current_value) or      # If user never set value
%         $current_value eq $default_value) { # or set to default
%         if ($always) {
# set <% $option->name() %> = <% $quote . $default_value . $quote %>
%         }
%       } else { # User-provided value, print value with default in comment
set <% $option->name() %> = <% $quote . $current_value . $quote %> # default: <% $quote . $default_value . $quote %>
%       }
</%method>
